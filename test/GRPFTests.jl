using Test
using Profile
# using Gadfly
using PlotlyJS
using SpecialFunctions

include("../src/GRPF.jl")

"""
Linearly map function values within domain from `min_coord` to `max_coord`.
"""
function mapfunctionval(z, ra, rb, ia, ib)
    zr = ra*real(z) + rb
    zi = ia*imag(z) + ib
    complex(zr, zi)
end
function mapfunctionval!(z, ra, rb, ia, ib)
    for ii in eachindex(z)
        z[ii] = mapfunctionval(z[ii], ra, rb, ia, ib)
    end
end

"""
Linearly map geometry values ‚àà {`min_coord`, `max_coord`} to domain bounds.

Also, there are floating point imprecisions when converting back and forth.
"""
function geom2fcn(pt::AbstractPoint2D, ra, rb, ia, ib)
    complex((getx(pt) - rb)/ra, (gety(pt) - ib)/ia)
end
geom2fcn(edge::DelaunayEdge, ra, rb, ia, ib) = (geom2fcn(geta(edge), ra, rb, ia, ib), geom2fcn(getb(edge), ra, rb, ia, ib))


@testset "Simple Rational Function" begin
    function simplefcn(z)
        w = (z - 1)*(z - im)^2*(z + 1)^3/(z + im)
    end

    # Analysis parameters
    xb = -2.  # real part begin
    xe = 2.  # real part end
    yb = -2.  # imag part begin
    ye = 2.  # imag part end
    r = 0.1  # initial mesh step
    tolerance = 1e-9

    origcoords = rectangulardomain(complex(xb, yb), complex(xe, ye), r)

    rmin, rmax = minimum(real(origcoords)), maximum(real(origcoords))
    imin, imax = minimum(imag(origcoords)), maximum(imag(origcoords))

    ra = (max_coord-min_coord)/(rmax-rmin)
    rb = max_coord - ra*rmax

    ia = (max_coord-min_coord)/(imax-imin)
    ib = max_coord - ia*imax

    mapfunctionval!(origcoords, ra, rb, ia, ib)
    newnodes = [IndexablePoint2D(real(coord), imag(coord), idx) for (idx, coord) in enumerate(origcoords)]
    tess = DelaunayTessellation2D{IndexablePoint2D}(2000)

    tess, ùìî, quadrants = tesselate!(tess, newnodes, pt -> simplefcn(geom2fcn(pt, ra, rb, ia, ib)),
                                    e -> geom2fcn(e, ra, rb, ia, ib), tolerance)

    # x, y = getplotxy(delaunayedges(tess))
    # t1 = PlotlyJS.scatter(;x=x, y=y) # mode="markers", marker_size=3)
    # l = Layout(width=600, height=600)
    # PlotlyJS.plot(t1, l)

    # rz = geom2fcn.(regions[1])
    # t1 = PlotlyJS.scatter(;x=real(rz), y=imag(rz), mode="markers", marker_size=6)
    # l = Layout(width=600, height=600)
    # PlotlyJS.plot(t1, l)

    ùê∂ = contouredges(tess, ùìî)
    regions = evaluateregions!(ùê∂, e -> geom2fcn(e, ra, rb, ia, ib))

    zroots, zroots_multiplicity, zpoles, zpoles_multiplicity = rootsandpoles(regions, quadrants, e -> geom2fcn(e, ra, rb, ia, ib))
    println("zroots: ")
    display(zroots)
    println("\nzpoles: ")
    display(zpoles)
    println()

    @test count(real(zroots) .> 0) == 2
    @test count(imag(zroots) .> 0) == 2
end

@testset "Complex Modes" begin
    function complexmodes(z)
        z *= 10
        f = 5e9
        c = 3e8
        Œº‚ÇÄ = 4e-7œÄ
        œµ‚ÇÄ = 1e-9/36/œÄ
        a = 6.35e-3
        b = 10e-3
        œµ·µ£‚ÇÅ = 10
        œµ·µ£‚ÇÇ = 1
        m = 1

        œâ = 2œÄ*f
        k‚ÇÄ = œâ/c
        Œ± = real(z)*k‚ÇÄ
        Œ≤ = imag(z)*k‚ÇÄ
        Œ≥ = Œ± + im*Œ≤
        œµ‚ÇÅ = œµ‚ÇÄ*œµ·µ£‚ÇÅ
        œµ‚ÇÇ = œµ‚ÇÄ*œµ·µ£‚ÇÇ
        Œº‚ÇÅ = Œº‚ÇÄ
        Œº‚ÇÇ = Œº‚ÇÄ
        Œ∫‚ÇÅ = sqrt(Œ≥^2 + k‚ÇÄ^2*œµ·µ£‚ÇÅ)
        Œ∫‚ÇÇ = sqrt(Œ≥^2 + k‚ÇÄ^2*œµ·µ£‚ÇÇ)
        Œ∑‚ÇÅ = sqrt(Œº‚ÇÅ/œµ‚ÇÅ)
        Œ∑‚ÇÇ = sqrt(Œº‚ÇÇ/œµ‚ÇÇ)

        Jm_a1 = besselj1(Œ∫‚ÇÅ*a)
        Jm_a2 = besselj1(Œ∫‚ÇÇ*a)
        Ym_a2 = bessely1(Œ∫‚ÇÇ*a)
        Jm_b2 = besselj1(Œ∫‚ÇÇ*b)
        Ym_b2 = bessely1(Œ∫‚ÇÇ*b)
        DJm_a1 = (besselj0(Œ∫‚ÇÅ*a) - besselj(2, Œ∫‚ÇÅ*a))/2
        DJm_a2 = (besselj0(Œ∫‚ÇÇ*a) - besselj(2, Œ∫‚ÇÇ*a))/2
        DJm_b2 = (besselj0(Œ∫‚ÇÇ*b) - besselj(2, Œ∫‚ÇÇ*b))/2
        DYm_a2 = (bessely0(Œ∫‚ÇÇ*a) - bessely(2, Œ∫‚ÇÇ*a))/2
        DYm_b2 = (bessely0(Œ∫‚ÇÇ*b) - bessely(2, Œ∫‚ÇÇ*b))/2

        W = @SMatrix [Jm_a1                 0                       -Jm_a2              -Ym_a2              0                       0;
                      0                     Jm_a1/Œ∑‚ÇÅ                0                   0                   -Jm_a2/Œ∑‚ÇÇ               -Ym_a2/Œ∑‚ÇÇ;
                      Œ≥*m*Jm_a1/(a*Œ∫‚ÇÅ^2)    -œâ*Œº‚ÇÅ*DJm_a1/(Œ∫‚ÇÅ*Œ∑‚ÇÅ)    -Œ≥*m*Jm_a2/(a*Œ∫‚ÇÇ^2) -Œ≥*m*Ym_a2/(a*Œ∫‚ÇÇ^2) œâ*Œº‚ÇÇ*DJm_a2/(Œ∫‚ÇÇ*Œ∑‚ÇÇ)     œâ*Œº‚ÇÇ*DYm_a2/(Œ∫‚ÇÇ*Œ∑‚ÇÇ);
                      -œâ*œµ‚ÇÅ*DJm_a1/Œ∫‚ÇÅ       -m*Œ≥*Jm_a1/(a*Œ∫‚ÇÅ^2*Œ∑‚ÇÅ)  œâ*œµ‚ÇÇ*DJm_a2/Œ∫‚ÇÇ      œâ*œµ‚ÇÇ*DYm_a2/Œ∫‚ÇÇ      m*Œ≥*Jm_a2/(a*Œ∫‚ÇÇ^2*Œ∑‚ÇÇ)   m*Œ≥*Ym_a2/(a*Œ∫‚ÇÇ^2*Œ∑‚ÇÇ);
                      0                     0                       Jm_b2               Ym_b2               0                       0;
                      0                     0                       Œ≥*m*Jm_b2/(b*Œ∫‚ÇÇ^2)  Œ≥*m*Ym_b2/(b*Œ∫‚ÇÇ^2)  -œâ*Œº‚ÇÇ*DJm_b2/(Œ∫‚ÇÇ*Œ∑‚ÇÇ)    -œâ*Œº‚ÇÇ*DYm_b2/(Œ∫‚ÇÇ*Œ∑‚ÇÇ)]
        w = det(W)
    end

    R = 1.
    r = 0.15

    origcoords = diskdomain(R, r)
    tolerance = 1e-9

    rmin, rmax = minimum(real(origcoords)), maximum(real(origcoords))
    imin, imax = minimum(imag(origcoords)), maximum(imag(origcoords))

    ra = (max_coord-min_coord)/(rmax-rmin)
    rb = max_coord - ra*rmax

    ia = (max_coord-min_coord)/(imax-imin)
    ib = max_coord - ia*imax

    mapfunctionval!(origcoords, ra, rb, ia, ib)
    newnodes = [IndexablePoint2D(real(coord), imag(coord), idx) for (idx, coord) in enumerate(origcoords)]
    tess = DelaunayTessellation2D{IndexablePoint2D}(2000)

    tess, ùìî, quadrants = tesselate!(tess, newnodes, pt -> complexmodes(geom2fcn(pt, ra, rb, ia, ib)),
                                    e -> geom2fcn(e, ra, rb, ia, ib), tolerance)

    ùê∂ = contouredges(tess, ùìî)
    regions = evaluateregions!(ùê∂, e -> geom2fcn(e, ra, rb, ia, ib))

    zroots, zroots_multiplicity, zpoles, zpoles_multiplicity = rootsandpoles(regions, quadrants, e -> geom2fcn(e, ra, rb, ia, ib))
    println("zroots: ")
    display(zroots)
    println("\nzpoles: ")
    display(zpoles)
    println()

    @test count(real(zroots) .> 0) == 6
    @test count(imag(zroots) .> 0) == 5
end

@testset "Lossy Multilayered Waveguide" begin
    function wvgd(z)
        ns = 0.065-4im
        n1 = 1.5835
        nc = 1.0
        d1 = 1.81e-6
        Œª‚ÇÄ = 0.6328e-6
        k‚ÇÄ = 2œÄ/Œª‚ÇÄ
        k‚ÇÄd1 = k‚ÇÄ*d1
        Œ∫1 = sqrt(n1^2 - z^2)
        Œ≥s = sqrt(z^2 - ns^2)
        Œ≥c = sqrt(z^2 - nc^2)
        m11 = cos(Œ∫1*k‚ÇÄd1)
        m12 = im/Œ∫1*sin(Œ∫1*k‚ÇÄd1)
        m21 = im*Œ∫1*sin(Œ∫1*k‚ÇÄd1)
        m22 = cos(Œ∫1*k‚ÇÄd1)
        w = det([1.0    -m11+im*Œ≥c*m12
                 im*Œ≥s  -m21+im*Œ≥c*m22])
    end

    # Analysis parameters
    xb = 1.  # real part begin
    xe = 2.5  # real part end
    yb = -1.  # imag part begin
    ye = 1.  # imag part end
    r = 0.5  # initial mesh step
    tolerance = 1e-9

    origcoords = rectangulardomain(complex(xb, yb), complex(xe, ye), r)

    rmin, rmax = minimum(real(origcoords)), maximum(real(origcoords))
    imin, imax = minimum(imag(origcoords)), maximum(imag(origcoords))

    ra = (max_coord-min_coord)/(rmax-rmin)
    rb = max_coord - ra*rmax

    ia = (max_coord-min_coord)/(imax-imin)
    ib = max_coord - ia*imax

    mapfunctionval!(origcoords, ra, rb, ia, ib)
    newnodes = [IndexablePoint2D(real(coord), imag(coord), idx) for (idx, coord) in enumerate(origcoords)]
    tess = DelaunayTessellation2D{IndexablePoint2D}(2000)

    tess, ùìî, quadrants = tesselate!(tess, newnodes, pt -> wvgd(geom2fcn(pt, ra, rb, ia, ib)),
                                    e -> geom2fcn(e, ra, rb, ia, ib), tolerance)

    # x, y = getplotxy(delaunayedges(tess))
    # t1 = PlotlyJS.scatter(;x=x, y=y) # mode="markers", marker_size=3)
    # l = Layout(width=600, height=600)
    # PlotlyJS.plot(t1, l)
    #
    # rz = geom2fcn.(regions[1])
    # t1 = PlotlyJS.scatter(;x=real(rz), y=imag(rz), mode="markers", marker_size=6)
    # l = Layout(width=600, height=600)
    # PlotlyJS.plot(t1, l)

    ùê∂ = contouredges(tess, ùìî)
    regions = evaluateregions!(ùê∂, e -> geom2fcn(e, ra, rb, ia, ib))

    zroots, zroots_multiplicity, zpoles, zpoles_multiplicity = rootsandpoles(regions, quadrants, e -> geom2fcn(e, ra, rb, ia, ib))
    println("zroots: ")
    display(zroots)
    println("\nzpoles: ")
    display(zpoles)
    println()

    @test count(real(zroots) .> 0) == 7
    @test count(imag(zroots) .> 0) == 0
end

@testset "Graphene Transmission Line" begin
    function graphenefunction(z)
        f = 1e12
        c = 299792458.
        Œº‚ÇÄ = 4œÄ*1e-7
        œµ‚ÇÄ = 1/(Œº‚ÇÄ*c^2)

        e = 1.602176565e-19
        kB = 1.3806488e-23
        hk = 1.05457168e-34
        vFe = 1e6
        muc = 0.05*e
        t = 0.135e-12
        T = 300
        œµ·µ£‚ÇÅ = 1.
        œµ·µ£‚ÇÇ = 11.9

        œâ = 2œÄ*f
        k‚ÇÄ = œâ/c
        k·µ£‚ÇÄ = -im*z*k‚ÇÄ

        Slo=-im*e^2*kB*T*log(2+2*cosh(muc/kB/T)) / (œÄ*hk^2*(œâ-im/t))

        a = -3*vFe^2*Slo/(4*(œâ-im/t)^2)
        b = a/3

        Y1TM = œâ*œµ·µ£‚ÇÅ*œµ‚ÇÄ/sqrt(œµ·µ£‚ÇÅ*k‚ÇÄ^2 - k·µ£‚ÇÄ^2);
        Y2TM = œâ*œµ·µ£‚ÇÇ*œµ‚ÇÄ/sqrt(œµ·µ£‚ÇÇ*k‚ÇÄ^2 - k·µ£‚ÇÄ^2);
        YSTM = Slo + 1*a*k·µ£‚ÇÄ^2 + 1*b*k·µ£‚ÇÄ^2;

        w = (Y1TM + Y2TM + YSTM)*(-Y1TM + Y2TM + YSTM)*(Y1TM - Y2TM + YSTM)*(-Y1TM - Y2TM + YSTM) # four Riemann sheets
    end

    # Analysis parameters
    xb = -100.  # real part begin
    xe = 400.  # real part end
    yb = -100.  # imag part begin
    ye = 400.  # imag part end
    r = 18.  # initial mesh step
    tolerance = 1e-9

    origcoords = rectangulardomain(complex(xb, yb), complex(xe, ye), r)

    rmin, rmax = minimum(real(origcoords)), maximum(real(origcoords))
    imin, imax = minimum(imag(origcoords)), maximum(imag(origcoords))

    ra = (max_coord-min_coord)/(rmax-rmin)
    rb = max_coord - ra*rmax

    ia = (max_coord-min_coord)/(imax-imin)
    ib = max_coord - ia*imax

    origcoords = mapfunctionval.(origcoords, ra, rb, ia, ib)
    newnodes = [IndexablePoint2D(real(coord), imag(coord), idx) for (idx, coord) in enumerate(origcoords)]
    tess = DelaunayTessellation2D{IndexablePoint2D}(2000)

    tess, ùìî, quadrants = tesselate!(tess, newnodes, pt -> graphenefunction(geom2fcn(pt, ra, rb, ia, ib)),
                                    e -> geom2fcn(e, ra, rb, ia, ib), tolerance)

#
#     # x, y = getplotxy(delaunayedges(tess))
#     # set_default_plot_size(15cm, 15cm)
#     # p = plot(x=x, y=y, Geom.path, Scale.x_continuous(minvalue=1.0, maxvalue=2.0), Scale.y_continuous(minvalue=1.0, maxvalue=2.0))
#     # draw(SVG("graphenefunction.svg", 6inch, 6inch), p)
#
#     ùê∂ = contouredges(tess, ùìî)
#     regions = evaluateregions!(ùê∂, e -> geom2fcn(e, ra, rb, ia, ib))
#
#     zroots, zroots_multiplicity, zpoles, zpoles_multiplicity = rootsandpoles(regions, quadrants, e -> geom2fcn(e, ra, rb, ia, ib))
#     println("zroots: ")
#     display(zroots)
#     println("\nzpoles: ")
#     display(zpoles)
#     println()
#
#     @test count(real(zroots) .> 0) == 6
#     @test count(imag(zroots) .> 0) == 6
end

@testset "Default" begin
    function defaultfcn(z)
        f = 1e9
        œµ·µ£ = 5 - 2im
        Œº·µ£ = 1 - 2im
        d = 1e-2
        c = 3e8
        œâ = 2œÄ*f
        k‚ÇÄ = œâ/c
        cc = œµ·µ£^2*(k‚ÇÄ*d)^2*(œµ·µ£*Œº·µ£ - 1)
        w = œµ·µ£^2*z^2 + z^2*tan(z)^2 - cc
    end

    # Analysis parameters
    xb = -2.  # real part begin
    xe = 2.  # real part end
    yb = -2.  # imag part begin
    ye = 2.  # imag part end
    r = 0.2  # initial mesh step
    tolerance = 1e-9

    origcoords = rectangulardomain(complex(xb, yb), complex(xe, ye), r)

    rmin, rmax = minimum(real(origcoords)), maximum(real(origcoords))
    imin, imax = minimum(imag(origcoords)), maximum(imag(origcoords))

    ra = (max_coord-min_coord)/(rmax-rmin)
    rb = max_coord - ra*rmax

    ia = (max_coord-min_coord)/(imax-imin)
    ib = max_coord - ia*imax

    mapfunctionval!(origcoords, ra, rb, ia, ib)
    newnodes = [IndexablePoint2D(real(coord), imag(coord), idx) for (idx, coord) in enumerate(origcoords)]
    tess = DelaunayTessellation2D{IndexablePoint2D}(2000)

    @time begin
        tess, ùìî, quadrants = tesselate!(tess, newnodes, pt -> defaultfcn(geom2fcn(pt, ra, rb, ia, ib)),
                                        e -> geom2fcn(e, ra, rb, ia, ib), tolerance)

        ùê∂ = contouredges(tess, ùìî)
        regions = evaluateregions!(ùê∂, e -> geom2fcn(e, ra, rb, ia, ib))

        zroots, zroots_multiplicity, zpoles, zpoles_multiplicity = rootsandpoles(regions, quadrants, e -> geom2fcn(e, ra, rb, ia, ib))
    end
    println("zroots: ")
    display(zroots)
    println("\nzpoles: ")
    display(zpoles)
    println()

    @test count(real(zroots) .> 0) == 3
    @test count(imag(zroots) .> 0) == 3
end
